{"version":3,"file":"synapse-api.decorator.js","sourceRoot":"","sources":["../../../../../src/core/decorators/synapse-api.decorator.ts"],"names":[],"mappings":";;;;AAAA,OAAO,EAAE,iBAAiB,EAAE,MAAM,uBAAuB,CAAC;AAC1D,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,QAAQ,EAAE,MAAM,QAAQ,CAAC;;;;;;;;;;AAczD,MAAM,qBAAqB,aAAuE,EAAE;;IAElG,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;QAC5B,MAAM,CAAC,CAAC,IAAkC,EAAE,EAAE;YAC5C,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;gBAAC,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;aAAE;YAClD,UAAU,GAAG,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,EAAC,IAAI,oBAAE,UAAoB,CAAA,EAAC,CAAC,CAAC,mBAAC,SAAS,CAAC,UAAU,CAAqB,CAAA,CAAC;YAE7G,MAAM,CAAC,YAAY,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;SACvC,CAAC;KACH;IAAC,IAAI,CAAC,CAAC;;QAEN,MAAM,CAAC,YAAY,mBAAC,UAA0C,GAAE,EAAC,IAAI,EAAE,EAAE,EAAC,CAAC,CAAC;KAC7E;;;;;;IAED,sBAAsB,IAAkC,EAAE,IAAsB;;QAG9E,qBAAI,OAAO,qBAAiC,UAAS,GAAG,IAAW;;YAGjE,uBAAM,GAAG,GAAG,IAAI,CAAC,KAAK,mBAAC,IAAW,GAAE,IAAI,CAAC,CAAC;;;YAI1C,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;YAE7C,MAAM,CAAC,GAAG,CAAC;SACL,CAAA,CAAC;QAET,OAAO,GAAG,QAAQ,CAAC,OAAO,EAAE,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QAC7D,OAAO,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;;QAGnC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;QAErD,MAAM,CAAC,OAAO,CAAC;KAChB;;;;;;;IAED,kBAAsC,EAAK,EAAE,IAAY;QACvD,MAAM,mBAAC,IAAI,QAAQ,CAAC,IAAI,EAAE,mBAAmB,IAAI,6CAA6C,CAAC,CAAC,EAAE,CAAM,EAAC;KAC1G;CACF","sourcesContent":["import { SynapseApiReflect } from './synapse-api.reflect';\nimport { cloneDeep, isFunction, isString } from 'lodash';\nimport { SynapseApiConfig } from '../api-config.type';\nimport { Constructor } from '../../utils/utils';\nimport SynapseApiClass = SynapseApiReflect.SynapseApiClass;\n\n/**\n * Use this decorator on your web API class.\n *\n * You can specify an optional resource path to this API, or a complete {@link SynapseApiConfig},\n * that will applies to this class and all of its sub classes.\n *\n * @param confOrCtor\n * @returns\n */\nexport function SynapseApi(confOrCtor: string | SynapseApiConfig | Constructor<SynapseApiClass> = ''): ClassDecorator | any {\n  // if called SynapseApi(...???...)\n  if (!isFunction(confOrCtor)) {\n    return (ctor: Constructor<SynapseApiClass>) => {\n      if (!ctor) { throw new Error('assertion error'); }\n      confOrCtor = isString(confOrCtor) ? {path: confOrCtor as string} : cloneDeep(confOrCtor) as SynapseApiConfig;\n\n      return _makeNewCtor(ctor, confOrCtor);\n    };\n  } else {\n    // if called SynapseApi\n    return _makeNewCtor(confOrCtor as Constructor<SynapseApiClass>, {path: ''});\n  }\n\n  function _makeNewCtor(ctor: Constructor<SynapseApiClass>, conf: SynapseApiConfig): Constructor<SynapseApiClass> {\n\n    // decorate constructor to add config within reflect metadata\n    let newCtor: Constructor<SynapseApiClass> = function(...args: any[]): SynapseApiClass {\n\n      // call decoree constructor\n      const res = ctor.apply(this as any, args); // tslint:disable-line\n\n      // store conf within metadata.\n      // !!! It is important to call constructor before, to register config of any parent class decorated with @SynapseApi\n      SynapseApiReflect.init(ctor.prototype, conf);\n\n      return res;\n    } as any;\n\n    newCtor = renameFn(newCtor, ctor.prototype.constructor.name);\n    newCtor.prototype = ctor.prototype;\n\n    // copy static values\n    Object.keys(ctor).forEach(k => newCtor[k] = ctor[k]);\n\n    return newCtor;\n  }\n\n  function renameFn<T extends Function>(fn: T, name: string): T {\n    return new Function('fn', `return function ${name}() {\\n return fn.apply(this, arguments);\\n}`)(fn) as T;\n  }\n}\n"]}